# DecompAlgs

This is a magma package for working with axial algebras and decomposition algebras.  We define new magma objects for working with these objects and provide many functions for exploring their properties.

Decomposition algebras are defined here:

> [T. De Medts, S.F. Peacock, S. Shpectorov and M. Van Couwenberghe, Decomposition algebras and axial algebras, _J. Algebra_, **556** (2020), 287-314.](https://doi.org/10.1016/j.jalgebra.2020.02.027)

Axial algebras were defined in 2015 by J.I. Hall, F. Rehren and S. Shpectorov.  See for example, this survey paper:

> J. McInroy and S.Shpectorov, Algebras of Jordan and Monster type, _Proceedings of Groups St Andrews 2022_, to appear, [arXiv:2209.08043](https://arxiv.org/abs/2209.08043).

<details>
  <summary>Rough definition of axial algebras and decomposition algebras</summary>

### Rough definition
  Roughly speaking, an _axial algebra_ is an alegbra `A` which is generated by a set of special elements call _axes_.  An element is an _axis_ if it is a semisimple idempotent whose eigenspaces multiply according to a _fusion law_.  (Note that in this code, we do not assume/check that the algebra is generated by the axes.)


  A decomposition algebra generalises this by not requiring there to be axes (or eigenvalues).  Instead, we just have _decompositions_.  Each _decomposition_ `D` is a set of (vector) subspaces of `A`, called _parts_, which sum to give `A` and pairwise intersect trivially.  Elements in the parts multiply in the algebra according to the fusion law.

  For both axial and decomposition algebras, when the fusion law is graded, we get algebra automorphisms for each axis/decomposition - these are called _Miyamoto automorphisms_.  The group generated by these is called the _Miyamoto group_.
</details>

## Getting started

Begin by cloning the repository by running

    git clone --recurse-submodules https://github.com/SimonMaths/DecompAlgs
    
or

    git clone --recurse-submodules git@github.com:SimonMaths/DecompAlgs.git
    
This should also pull the submodules which are required here (FusionLaws which includes MagmaJson - this requires python v2.7 or above to load and save algebras.)

Now, when you are in the DecompAlgs directory start magma and attach the spec file

    AttachSpec("DecompAlgs.spec");

# Usage
Suppose we have a decomposition algebra `A`.  We give an overview of some of the avaliable functionality below.

## Algebra properties
We can find various properties of the algebra:

     Dimension(A);
     BaseRing(A);
     FusionLaw(A);
     IsCommutative(A); IsAssociative(A);

A decomposition algebra has a set of decompositions which can be obtained using:

     Decompositions(A);

This is an associative array which is indexed by the set

     IndexSet(A);

We can also change the base ring using `ChangeRing(A, F)` and find subalgebras (NB at the time of writing there is a bug in Magma's subalgebra constructor for non-associative algebras - our commands work round this)

     B := sub<A | S>;

## Axial algebra functions

For axial (decomposition) algebras, we have some additional functions, such as

     Axes(A);
     IsPrimitive(A);

## Decompositions and axes

Given a decomposition `D` of our algebra `A`, we can access the parts (these are the eigenspaces if it is an axial algebra) of the decomposition by using

    Parts(D);
    NumberOfParts(D);

We can access a specific parts using `Part(D, x)`.  If `A` is an axial algebra and `a` is an axis, we can access **a** decomposition and parts etc, similarly
```
Decomposition(a);
Parts(a);
```
Given an axis `a`, we can find the evaluation (i.e. the map to the eigenvalues) by
```
Evaluation(a);
```
## Algebra element functions

We can add and multiply elements `a` and `b` of our algebra in the normal way, as well as multiply by scalars:

    a + b; a*b; 3*a;

We can also test membership and equality.  Commands like `Basis` work too.

We can test if an element is an axis using `IsAxis(a)` and if it is, we can check for primitivity, `IsPrimitive(a)`, and find the projection `Projection(a, v)`.

## Miyamoto group

For the `i`th decomposition of `A`, we can return the Miyamoto involution using
```
g := MiyamotoElement(A, i)
```
The Miyamoto group is obtained using
```
G := MiyamotoGroup(A);
```
If possible, this is returned as a permutation group on a closed set of decompositions/axes.  We can check closure, or find a closed set of decompositions/axes using
```
IsMiyamotoClosed(A);
MiyamotoClosure(A);
```
We can act on elements `v` of the algebra, or a decomposition `D` by `g` in the natural way:
```
v*g
D*g
```
We can also find decomposition and axis orbit representatives naturally:
```
DecompositionOrbitRepresentatives(A);
AxisOrbitRepresentatives(A);
```

## Frobenius form
We can check whether an axial algebra `A` has a Frobenius form using
```
so, M := HasFrobeniusForm(A);
```
If so it returns the Gram matrix `M`, which can also be accessed via `FrobeniusForm(A)`.  Given two elements of the algebra, `u` and `v`, we can get their value in the form
```
Frobenius(u, v)
```

## Saving and loading

We can save and load our algebras.  These are stored in a library database

    SaveDecompositionAlgebra(A, filename);
    A := LoadDecompositionAlgbera(filename);
